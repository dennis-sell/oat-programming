/* An implementation of Strings with various analytical functions. */


#ifndef __STRING_OAT__
#define __STRING_OAT__

/*class ListItem <: Object {
  string s;
  ListItem? prev;
  ListItem? next;

  new (string s)()
    this.s = s;
  {
    this.prev = null;
    this.next = null;
  }
};

class List <: Object {
  int contentsLength;
  ListItem? head;
  ListItem? tail;

  new ()() {
    this.head = null;
    this.tail = null;
    this.contentsLength = 0;
  }

  unit clear() {
    this.contentsLength = 0;
    this.head = null;
    this.tail = null;
    return;
  }

  unit addString(string s) {
    ListItem elem = new ListItem(s);
    this.contentsLength = this.contentsLength + length(s);
    if (this.head == null) {
      this.head = elem;
      this.tail = elem;
    } else {
      this.tail.next = elem;
      elem.prev = this.tail;
      this.tail = elem;
    }
    return;
  }

/* Should probably redo this to not run in O(n^2) * /
  string getContents() {
    ListElem current = this.head;
    string contents = "";
    /*int[] contents = int[this.contentsLength];
    int counter = 0; */
    /*if (this.contentsLength == 0) {
      return contents;
    }* /
    while (current != null) {
      contents = concat(contents, current.s);
    }
    return contents;   
  }

};
*/

int min(int a, int b) {
  int max = 0;
  if (a > b) {
    max = a;
  } else { 
    max = b;
  }
  return max;
}

int length(string s) {
  return length_of_string(s);
}

string concat(string s1, string s2) {
  int len1 = length(s1);
  int len2 = length(s2);
  int[] string1 = array_of_string(s1);
  int[] string2 = array_of_string(s2);
  int[] newString = new int [len1 + len2] (fun i -> 0);
  for (int i = 0; i < len1; i=i+1;) {
    newString[i] = string1[i];
  }
  for (int i = 0; i < len2; i=i+1;) {
    newString[i + len1] = string2[i];
  }
  return string_of_array(newString);
}

string charAt(int i, string str) {
  int[] charArray = array_of_string(str);
  int[] c = {charArray[i]};
  return string_of_array(c);
}

bool equals(string s1, string s2) {
  int[] arr1 = array_of_string(s1);
  int[] arr2 = array_of_string(s2);
  int len1 = length(s1);
  bool equivalent = true;
  if (len1 != length(s2)) {
    equivalent = false;
  }
  for (int i = 0; i < len1; i=i+1;) {
    if (arr1[i] != arr2[i]) equivalent = false;
  }
  return equivalent;
}

/* Returns the index of the first occurence of the entire substring within the main string passed in.
   If the substring is not found it returns -1. This function works for any length string, including
   those with length 1 which essentially represent chars. */
int indexOf(string substring, string mainstring) {
  int[] sub = array_of_string(substring);
  int[] main = array_of_string(substring);
  int len = length(mainstring);
  int length_of_sub = length(substring);
  int location = -1;
  for (int i = 0; (i < len) & (location < 0); i=i+1;) {
    if (main[i] == sub[0]) {
      if (equals(substring2(mainstring, i, i + length_of_sub), substring)) {
	location = i;
      }
    }
  }
  return location;
}

int indexOf2(string substring, string main, int start) {
  string shortenedMain = substring(main, start);
  return indexOf(substring, shortenedMain);
}  

string substring(string s, int start) {
  int[] str = array_of_string(s);
  int newLen = length(s) - start;
  string result = "";
  if ((newLen > 0) & (start >= 0)) {
    int[] newString = new int[newLen] (fun i -> 0);
    int oldLen = length(s);
    for (int i = 0; i < newLen; i=i+1;) {
      newString[i] = str[i + oldLen]; 
    }
    result = string_of_array(newString);
  }
  return result;
}


/* Returns the substring begining at the start index and including all chars up to the end index (inclusive) */
string substring2(string s, int start, int end) {
  int len = length(s);
  int[] str = array_of_string(s);
  string result = "";
  if ((start >= 0) & (end >= 0) & (start < len) 
                   & (end < len) & (start < end)) {
    int [] newString = new int [end - start] (fun i -> 0);
    for (int i = 0; i < end - start; i=i+1;) {
      newString[i] = str[start + i];
    }
    result = string_of_array(newString);
  }
  return result;
}
  

string toLowerCase(string s) {
  int[] str = array_of_string(s);
  int len = length(s);
  for (int i = 0; i < len; i=i+1;) {
    if ((str[i] >= 65) & (str[i] <= 90)) str[i] = str[i] + 32;
  }
  return string_of_array(str); 
}

string toUpperCase(string s) {
  int[] str = array_of_string(s);
  int len = length(s);
  for (int i = 0; i < len; i=i+1;) {
    if ((str[i] >= 97) & (str[i] <= 112)) str[i] = str[i] - 32;
  }
  return string_of_array(str);
}

/* Removes whitespace at the beginning and the end of a string. */
string trim(string s) {
  int[] str = array_of_string(s);
  int start = 0;
  int end = length(s);
  int curr = str[start];
  while (curr == 32 | curr == 9 | curr == 10) {
    start = start + 1;
    curr = str[start];
  }
  curr = str[end -1];
  while (curr == 32 | curr == 9 | curr == 10) {
    end = end - 1;
    curr = str[end - 1];
  }
  return substring2(s, start, end);
}

/* Uses dynamic programming to determine the minimum number of insertions, deletions, 
   and substitutions needed to get from one string to the other. */
int levenshteinDistance(string s1, string s2) {
  int len1 = length(s1);
  int len2 = length(s2);
  int[][] p = new int[][len2] (fun i -> new int[len1](fun j -> 0));

  int[] s = array_of_string(s1);
  int[] t = array_of_string(s2);
  
  for (int i = 0; i < len1; i=i+1;) {
    p[i][0] = 0;
  }

  for (int i = 0; i < len2; i=i+1;) {
    p[0][i] = 0;
  } 
  
  for (int i = 1; i < len2; i=i+1;) {
    for (int j = 1; j < len1; j=j+1;) {      
	if (s[i] == t[j]) {
          p[i][j] = p[i-1][j-1];
        } else {
          p[i][j] = min( p[i][j-1], min(p[i-1][j], p[i-1][j-1])) + 1;
        }
    }
  }
  return p[len1 - 1][len2 -1];
}
		

bool contains(string sub, string s) {
  return indexOf(sub, s) != -1;
}

bool isAlpha(string s) {
  int[] str = array_of_string(s);
  int len = length(s);
  bool isAlpha = true;
  for (int i = 0; (i < len) & isAlpha; i=i+1;) {
    if ( !((str[i] >= 65 & str[i] <= 90) | (str[i] >= 97 & str[i] <= 112)) )   
      isAlpha = false;
  }
  return isAlpha;
}
  
bool isAlphaNum(string s) {
  int[] str = array_of_string(s);
  int len = length(s);
  bool isAlphaNum = true;
  for (int i = 0; (i < len) & isAlphaNum; i=i+1;) {
    if ( !((str[i] >= 65 & str[i] <= 90) | 
           (str[i] >= 97 & str[i] <= 112) |
           (str[i] >= 48 & str[i] <= 57)) ) isAlphaNum = false;
  }
  return isAlphaNum;
}

bool startsWith(string sub, string main) {
  return indexOf(sub, main) == 0;
}

bool endsWith(string sub, string main) {
  return startsWith(substring(main, length(main) - length(sub)), sub);
}

int program (int argc, string[] argv) {
  string s1 = "cat";
  string s2 = "dog";
  print_string(concat(s1, s2));
  return 0;
}

/* equals, concatenate, indexOf (String) (String, int), length, toLowerCase, toUpperCase, words, unwords, lines, unlines, split, merge, replace, ocurrences, Levenshtein, fromInt, toInt. getInteger, getToken(), String Buffer, contains, trim, removeWhitespace, valueOf, startsWith, endsWith, isAlpha, isAlphaNum, substring

Still to do:
words, unwords, lines, unlines, split, merge, replace, ocurrences, fromInt, toInt. getInteger, getToken(), trim, removeWhitespace remove, valueOf

Maybe Regexes

*/


#endif
